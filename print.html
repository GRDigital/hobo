<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>hobo book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="hobo is a Rust frontend framework">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> hobo</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="basic-concepts.html"><strong aria-hidden="true">3.</strong> Core Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic-concepts/element.html"><strong aria-hidden="true">3.1.</strong> hobo::Element components</a></li><li class="chapter-item expanded "><a href="basic-concepts/traits.html"><strong aria-hidden="true">3.2.</strong> Capability traits</a></li><li class="chapter-item expanded "><a href="basic-concepts/styling.html"><strong aria-hidden="true">3.3.</strong> Styling facilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic-concepts/styling/selector.html"><strong aria-hidden="true">3.3.1.</strong> Selector</a></li><li class="chapter-item expanded "><a href="basic-concepts/styling/property.html"><strong aria-hidden="true">3.3.2.</strong> Property</a></li><li class="chapter-item expanded "><a href="basic-concepts/styling/at-rules.html"><strong aria-hidden="true">3.3.3.</strong> @-rules</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="state.html"><strong aria-hidden="true">4.</strong> Managing state with e!()</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="state/raw_element.html"><strong aria-hidden="true">4.1.</strong> Raw element access</a></li><li class="chapter-item expanded "><a href="state/rc_refcell.html"><strong aria-hidden="true">4.2.</strong> Rc&lt;RefCell&lt;T&gt;&gt;</a></li><li class="chapter-item expanded "><a href="state/hobo_trick.html"><strong aria-hidden="true">4.3.</strong> #[hobo::trick]</a></li><li class="chapter-item expanded "><a href="state/state.html"><strong aria-hidden="true">4.4.</strong> State and StateSlice</a></li></ol></li><li class="chapter-item expanded "><a href="building-the-dom.html"><strong aria-hidden="true">5.</strong> Building the DOM</a></li><li class="chapter-item expanded "><a href="utilities.html"><strong aria-hidden="true">6.</strong> Other utilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="utilities/web_str.html"><strong aria-hidden="true">6.1.</strong> web_str</a></li><li class="chapter-item expanded "><a href="utilities/slot.html"><strong aria-hidden="true">6.2.</strong> Slot</a></li></ol></li><li class="chapter-item expanded "><a href="recipes.html"><strong aria-hidden="true">7.</strong> Recipes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="recipes/elements-that-change.html"><strong aria-hidden="true">7.1.</strong> Elements that change</a></li><li class="chapter-item expanded "><a href="recipes/svgs.html"><strong aria-hidden="true">7.2.</strong> SVGs</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">hobo book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#hobo" id="hobo">hobo</a></h1>
<p><strong>hobo</strong> is a Rust frontend framework. Works on <strong>stable Rust</strong>.<br />
<strong>STILL WIP AND EXPERIMENTAL</strong> although used in production by <a href="https://grdigital.co.uk/">GR Digital</a>.</p>
<ul>
<li><strong>no virtual DOM</strong> - html elements are managed manually and can be accessed directly via <code>web_sys::HtmlElement</code> to manage attributes/contents/etc</li>
<li>no Model-View-Update (aka Elm architecture) - state management is manual, although there are helpful utilities</li>
<li>no HTML macros - just Rust</li>
<li>built-in macro-based styling, kind of like JS in CSS except it's just Rust</li>
</ul>
<p>In practice, the code ends up being no more verbose than with more conventional frontend frameworks, however quite a bit more straightforward.</p>
<h1><a class="header" href="#roadmaptodo" id="roadmaptodo">Roadmap/TODO:</a></h1>
<ul>
<li><strong>SSR</strong></li>
<li>@-rules support</li>
<li>More thorough testing</li>
<li><code>CSSStyleSheet.insertRule()</code> in release</li>
<li>Threading support</li>
</ul>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>Here's a basic counter component:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hobo::{prelude::*, enclose as e, cmp};

#[derive(hobo::Element, hobo::Container, hobo::EventTarget, hobo::RawElement)]
pub struct Counter {
	element: cmp::Div,
	count: i32,
}

// &lt;div&gt;
//   &lt;button&gt;PLUS&lt;/button&gt;
//   &lt;div&gt;0&lt;/div&gt;
// &lt;/div&gt;
impl Counter {
	#[hobo::trick]
	fn new() -&gt; Self {
		// we need this to be able to clone raw element reference into on_click handlers
		let text = cmp::div().text(&quot;0&quot;);

		Self { element: cmp::div(), count: 0 }
			.class(css::class!(
				css::width!(128 px),
				css::height!(128 px),
				// #AA0000FF or #AA0000 of #A00 in css
				// hobo requires full rgba though
				css::background_color!(0xAA_00_00_FF),
			))
			.child(cmp::button()
				.text(&quot;PLUS&quot;)
				.on_click_mut(&amp;this, e!((*text) move |this, _| {
					this.count += 1;
					text.set_inner_text(&amp;this.count.to_string());
				}))
			)
			.child(text)
	}
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#core-concepts" id="core-concepts">Core Concepts</a></h1>
<p>This chapter outlines core traits and styling facilities that <code>hobo</code> employs.</p>
<h1><a class="header" href="#hoboelement" id="hoboelement">hobo::Element</a></h1>
<p>Anything implementing <code>hobo::Element</code> is considered a hobo component. It is derivable on structs where there is a field named <code>element</code> which also implements <code>hobo::Element</code> or on enums with single-element tuple variants, where each of those implements <code>hobo::Element</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(hobo::Element)]
struct Foo {
	element: cmp::Div,
}

// also ok
#[derive(hobo::Element)]
enum Bar {
	Foo(Foo),
	Div(cmp::Div),
}
<span class="boring">}
</span></code></pre></pre>
<p>All basic HTML and SVG elements have a shortcut for creating them with a <code>cmp::&lt;tag&gt;</code> syntax. The type is a <code>hobo::BasicElement&lt;T&gt;</code> where <code>T</code> is the most appropriate <code>web_sys</code> type, aliased as <code>cmp::&lt;Tag&gt;</code>. In other words, calling <code>cmp::div()</code> creates a <code>cmp::Div</code>. It is also implemented for most smart pointers, check the docs for more.</p>
<h1><a class="header" href="#capability-traits" id="capability-traits">Capability traits</a></h1>
<p>There are several derivable traits, usually derived alongside <code>hobo::Element</code>, which denote a provided capability of some components. That is to say, deriving all of them always isn't necessary, but more like describing what can some component do.</p>
<ul>
<li><code>hobo::Container</code> - for components that can have children, which is most HTML elements except <code>&lt;input&gt;</code> and the like.</li>
<li><code>hobo::EventTarget</code> - for components that can handle keyboard/mouse/etc events.</li>
<li><code>hobo::RawElement</code> - for components which have a known particular web_sys element which can be extracted. <code>Box&lt;dyn hobo::Element&gt;</code> is a valid component, but the type of underlying element is lost.</li>
<li><code>hobo::Replaceable</code> - for components which can be replaced with an instance of themselves, usually it's used for a <code>Rc&lt;RefCell&lt;T&gt;&gt; where T: hobo::Element</code>.</li>
</ul>
<h1><a class="header" href="#styling-facilities" id="styling-facilities">Styling facilities</a></h1>
<p>Most hobo components will be styled with either <code>.class()</code> or <code>.style()</code> functions, where either <code>css::class!()</code>, <code>css::style!()</code> or <code>css::properties!()</code> macros are used. The naming is confusing somewhat, but the distinction is important.</p>
<ul>
<li><code>.style()</code> and <code>.set_style()</code> use the <code>style</code> attribute, which can only take a bunch of properties without any selectors, so <code>css::properties!()</code> macro is used.</li>
<li><code>.class()</code>, <code>.set_class()</code> and <code>.add_class()</code> use the <code>class</code> attribute:
<ul>
<li><code>css::style!()</code> uses a css-like <code>{ &lt;selector&gt; { &lt;properties&gt; } &lt;selector&gt; { &lt;properties&gt; } }</code> syntax</li>
<li><code>css::class!()</code> is <code>css::style!(.&amp; { &lt;properties&gt; })</code> or in other words - it's a bunch of properties applied just to the element being styled, similar to what can go in a <code>style</code> attribute, just using a class to refer to it.</li>
</ul>
</li>
</ul>
<p>For example, here's a style:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cmp::div()
	.class(css::style!(
		.&amp; {
			css::height!(393 px),
			css::Display::Flex,
			css::AlignItems::Center,
			css::Position::Relative,
		}

		.&amp; &gt; svg {
			css::width!(12 px),
			css::height!(100%),
			css::Cursor::Pointer,
			css::flex_shrink!(0),
			css::UserSelect::None,
		}

		.&amp; &gt; :not(:nth_child(1)) {
			css::z_index!(200),
		}

		.&amp; &gt; div:not(:nth_child(1)) {
			css::width!(17.5%),
			css::height!(100%),
			css::Display::Flex,
			css::AlignItems::Center,
		}

		.&amp;.&amp; &gt; :nth_child(5) {
			css::width!(30%),
		}

		.&amp; &gt; *:nth_child(3) &gt; img,
		.&amp; &gt; *:nth_child(4) &gt; img,
		.&amp; &gt; svg:last_child {
			css::Transform::Some(vec![css::TransformFunction::ScaleX((-1.).into())])
		}

		.&amp; &gt;&gt; img {
			css::height!(100%),
		}
	))
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Chaining vs non-chaining syntax:</strong> <code>.style()</code> is the chaining syntax, <code>.set_style()</code> is the non-chaining alternative. Similarly, <code>.class()</code> and <code>.set_class()</code>. On the other hand, <code>.add_class()</code> doesn't have a chanining equivalent. More about chaining vs non-chaining syntax in <a href="basic-concepts/../building-the-dom.html#chaining-vs-non-chaining-syntax">Building the DOM</a>.</p>
</blockquote>
<h1><a class="header" href="#selector" id="selector">Selector</a></h1>
<p>hobo selectors mirror css selectors with minor changes, most notably:</p>
<ul>
<li>descendant selectors like <code>div a</code> become <code>div &gt;&gt; a</code> because Rust doesn't have semantic whitespaces.
<ul>
<li>selectors like <code>div.active</code> work mostly the same (except have to be written like <code>div.(&quot;active&quot;)</code> or <code>div .(&quot;active&quot;)</code>)</li>
</ul>
</li>
<li>ids have to be written like <code>#(&quot;foo-1234&quot;)</code></li>
<li>pseudo-classes use <code>_</code> instead of <code>-</code> and must always use single colon syntax, e.g. <code>:active</code> or <code>:last_child</code>
<ul>
<li>there's an escape hatch in <code>:raw(&quot;-webkit-prop&quot;.to_string())</code> for browser-specific or other weird things</li>
</ul>
</li>
<li>pseudo-elements use <code>_</code> instead of <code>-</code> and must always use double colon syntax, e.g. <code>::after</code> or <code>::first_line</code></li>
</ul>
<p>There are also several additions:</p>
<ul>
<li><code>.&amp;</code> will be replaced at runtime with the name of a class, which will be generated from the rules in the style it belongs to
<ul>
<li>in other words, it's similar to <code>&amp;</code> in SASS or <code>styled-components</code></li>
</ul>
</li>
<li><code>.[T]</code> where <code>T</code> is some <code>hobo::Element</code> will be replaced with the generated classname for a type <code>T</code> so you could select based on component type. E.g. assuming you have a <code>Button</code> component, <code>.&amp; &gt;&gt; .[Button]</code> is a valid slector for all <code>Button</code> descendants of whatever this rule is applied to.</li>
</ul>
<h1><a class="header" href="#property" id="property">Property</a></h1>
<p>hobo property-collecting <code>css::properties!()</code> macro (internally used in <code>css::class()</code> and <code>css::style!()</code>) accepts anything which implements <code>hobo::css::AppendProperty</code>, which includes:</p>
<ul>
<li><code>css::Property</code> such as created by the <code>css::&lt;prop&gt;()</code> family of macros (e.g. <code>css::width!()</code>, <code>css::flex_shrink!()</code>, etc)</li>
<li><code>Vec&lt;css::Property&gt;</code></li>
<li><code>()</code></li>
<li><code>&amp;'static str</code> and <code>String</code> as escape hatches</li>
<li><code>FnOnce(&amp;mut Vec&lt;Property&gt;)</code> for rare complex logic</li>
<li>Unique types used as tuple variants in <code>css::Property</code>, e.g. <code>css::Display::Flex</code> is of type <code>css::Display</code> yet the variant is <code>css::Property::Display(css::Display)</code> so just <code>css::Display</code> can be used as a <code>hobo::css::AppendProperty</code> as well</li>
</ul>
<p>Conditional property inclusion is usually expressed as different <code>Vec&lt;css::Property&gt;</code> where one is empty, e.g.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>css::properties!(
	if active {
		vec![css::background_color!(0x00_00_FF_FF)],
	} else {
		vec![],
	},
)
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#-rules" id="-rules">@-rules</a></h1>
<p>Right now hobo only supports <code>@font-face</code>, but in the nearest future support for <code>@media</code>, <code>@import</code> and other is planned.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>@font-face {
	// raw string because this property hasn't been properly integrated into hobo yet
	&quot;src:url(...) format('woff2');&quot;,
	css::font_family!(&quot;Encode Sans&quot;),
	css::font_weight!(400),
	css::FontStyle::Normal,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#managing-state-with-e" id="managing-state-with-e">Managing state with e!()</a></h1>
<p>The <code>e!()</code>'s basic use is to just clone variables into closures, similar to what <a href="https://crates.io/crates/enclose">enclose</a> does.</p>
<p>There are several common hobo idioms which make use of it, which the next few chapters will outline.</p>
<h1><a class="header" href="#raw-element-access" id="raw-element-access">Raw element access</a></h1>
<p>Most simple event handlers, like clicks or hovers, usually just modify either style or contents of html elements in a way which doesn't not require any state manipulation apart from setting attributes or changing text. In this case, it's convenient to clone raw element reference into our <code>e!()</code> handlers.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>e!((*foo) move || {
	foo.set_inner_text(&quot;wooo&quot;);
})
<span class="boring">}
</span></code></pre></pre>
<p>would turn into something like</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
	// this clone is only of an html element reference,
	// it doesn't actually clone the element
	let foo = foo.raw_element().clone();
	move || {
		foo.set_inner_text(&quot;wooo&quot;);
	}
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#rcrefcellt" id="rcrefcellt">Rc&lt;RefCell&lt;T&gt;&gt;</a></h1>
<p>Since event handlers have to be <code>'static</code> it's, for the most part, not possible to express the lifetime relations between elements, their corresponding components, their event handlers and miscellaneous fields in those components. Thus, it's often pretinent to turn to runtime-checked <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>e!((%foo) move || {
	foo.bar = 50;
})
<span class="boring">}
</span></code></pre></pre>
<p>would turn into something like</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
	let foo = Rc::downgrade(&amp;foo);
	move || {
		let foo = if let Some(x) = Weak::upgrade(&amp;foo) { x } else { return; };
		{
			foo.bar = 50;
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>It is primarily useful to create event handlers which can be dropped when their owning component is dropped. Otherwise, there's an Rc cycle where the component owns an Rc of the event handler and the event handler owns an Rc of the component, so they leak memory. Since event handlers must be <code>'static</code> because they're passed to the DOM - it's not possible to tie its lifetime to the lifetime of the component.</p>
<p>Here's an example of a component making use of it:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(hobo::Element, hobo::Container, hobo::EventTarget)]
pub struct Checkbox {
	element: cmp::Input,
	value: Rc&lt;RefCell&lt;bool&gt;&gt;,
}

impl Checkbox {
	fn new(value: bool) -&gt; Self {
		let element = cmp::input().attr(web_str::r#type(), web_str::checkbox());
		element.element.set_checked(value);
		let value = Rc::new(RefCell::new(value));

		element.on_change(e!((%value, *element) move |_| {
			*value.borrow_mut() = element.checked();
			// we don't have to change any styling or anything -
			// the html checkbox element's state is already definitely
			// in sync with our internal value
			// changing the internal value is necessary so the parent component
			// can recover it without using raw html interface
			// e.g. in case we later swap from checkbox inputs to a custom checkbox
		}));

		Self { element, value }
	}
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#hobotrick" id="hobotrick">#[hobo::trick]</a></h1>
<p>This macro is usually applied to a component's <code>new()</code> constructor. Through some careful <code>MaybeUninit</code> trickery, it allows a special syntax for event handlers, which get a conveniently syntactically-sweetened <code>&amp;mut Self</code> rather than <code>Rc&lt;RefCell&lt;Self&gt;&gt;</code> or rather than having to pass a bunch of <code>Rc&lt;RefCell&lt;FieldT&gt;&gt;</code> into the event handler like <code>e!((%field1, %field2) move |_| { ... })</code>.</p>
<p>It injects a variable <code>this</code> of type <code>Rc&lt;MaybeUninit&lt;RefCell&lt;Self&gt;&gt;&gt;</code> which is not meant to be interacted with, but can be passed to <code>&lt;event&gt;_mut</code> and <code>add_&lt;event&gt;_mut</code> family of functions, and then the event handler can take <code>this</code> of type <code>&amp;mut Self</code> as the first argument. To bring back the simplified Counter example from the introduction:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(hobo::Element, hobo::Container, hobo::EventTarget, hobo::RawElement)]
pub struct Counter {
	element: cmp::Div,
	count: i32,
}

impl Counter {
	#[hobo::trick]
	fn new() -&gt; Self {
		Self { element: cmp::div(), count: 0 }
			.on_click_mut(&amp;this, move |this, _| {
				this.count += 1;
			})
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>is expanded to something like:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Counter {
	fn new() -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {
		let mut this: Rc&lt;MaybeUninit&lt;RefCell&lt;Self&gt;&gt;&gt; = Rc::new(MaybeUninit::uninit());
		let new_this = {
			let new_this = Self { element: cmp::div(), count: 0 };
			// this is just showing roughly what would .on_click_mut translate to
			let weak = Rc::downgrade(this);
			new_this
				.on_click(move |event| {
					let strong = if let Some(x) = weak.upgrade() { x } else { return; };
					let inited: Rc&lt;RefCell&lt;T&gt;&gt; = unsafe {
						Rc::from_raw((&amp;*Rc::into_raw(strong)).as_ptr())
					};
					let this = &amp;mut inited.borrow_mut();

					// original handler block
					{
						this.count += 1;
					}
				})
		};
		unsafe {
			let raw_uninit = Rc::into_raw(this) as *mut MaybeUninit&lt;_&gt;;
			let raw_init = (&amp;mut *raw_uninit).as_mut_ptr();
			std::ptr::write(raw_init, RefCell::new(new_this));
			Rc::from_raw(raw_init)
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>otherwise we'd have to write something like:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(hobo::Element, hobo::Container, hobo::EventTarget, hobo::RawElement)]
pub struct Counter {
	element: cmp::Div,
	count: Rc&lt;RefCell&lt;i32&gt;&gt;,
}

impl Counter {
	fn new() -&gt; Self {
		let count = Rc::new(RefCell::new(0));
		Self {
			element: cmp::div(),
				.on_click(e!((%count) move |_| {
					*count.borrow_mut() += 1;
				}))
			count,
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Which, while not much worse, would drastically blow up in complexity with more fields and more handlers.</p>
<h1><a class="header" href="#state" id="state">State</a></h1>
<p>Sometimes it's convenient to do actions in response to a state change within a component. HTMl events like clicks don't necessarily correspond to a state change, so a higher level abstraction is required.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(hobo::Element, hobo::Container, hobo::EventTarget, hobo::RawElement)]
pub struct Counter {
	element: cmp::Div,
	count: State&lt;i32&gt;,
}

impl Counter {
	fn new() -&gt; Self {
		let count = State::new(0);
		let text = cmp::div().text(&quot;0&quot;);

		// the return type is a SubscriptionKey
		// so we can unsub or resub throughout the component lifespan as we need
		count.subscribe_key(e!((%state count, *text) move || {
			text.set_inner_text(&amp;count.view().to_string());
		}));

		Self {
			element: cmp::div()
				.child(cmp::button()
					.text(&quot;MINUS&quot;)
					.on_click(e!((%state count) move |_| {
						*count.update() -= 1;
					}))
				)
				.child(cmp::button()
					.text(&quot;PLUS&quot;)
					.on_click(e!((%state count) move |_| {
						*count.update() += 1;
					}))
				)
				.child(text),
			count,
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#global-state" id="global-state">Global state</a></h2>
<p>Some operations are cross-cutting through the whole application, like caching DB responses and populating data which may be used across many components. One way to handle this is some kind of global state, this is what Redux and the like achieve.</p>
<p>In <code>hobo</code> we can use a static <code>StateSlice</code> to achieve a similar result. </p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use once_cell::sync::Lazy;

#[derive(Default)]
pub struct GlobalState {
	pub foo: HashMap&lt;String, i32&gt;,
	pub bar: u32,
}

pub static STATE: Lazy&lt;StateSlice&lt;GlobalState&gt;&gt; = Lazy::new(GlobalState::default);
	
// ...

#[derive(hobo::Element)]
struct FooCmp {
	element: cmp::Div,
	// ...
	subscription: Subscription,
}

impl FooCmp {
	fn new() -&gt; Self {
		let subscription = STATE.subscribe(e!((...) move || {
			// ...
		}));

		// ...

		Self { element, subscription }
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Later, when <code>FooCmp</code> is dropped, <code>subscription</code> will be unsubscribed as well. This is the difference between <code>.subscribe()</code> and <code>.and subscribe_key()</code> - the latter only returns a key which has to be used manually, while the former returns both the key and a reference to <code>StateSlice</code> it was taken from so the unsubscribing happens on drop automatically.<br />
<code>GlobalState</code> can have nested <code>StateSlice</code>s for a more fine-grained control. Similarly, you can have more than one <code>GlobalState</code> - there's no hidden shared state to worry about.</p>
<blockquote>
<p><strong>Note:</strong> updating <code>State</code> or <code>StateSlice</code> from a subscription function will re-trigger all subscriptions once the update is finished, so be mindful of infinite update loops.</p>
</blockquote>
<h1><a class="header" href="#building-the-dom" id="building-the-dom">Building the DOM</a></h1>
<p>Assembling components is usually done via function chaining, but every function has a non-chained variant for use in loops or in case ownership gets tricky.</p>
<p>Here's an example of a somewhat involved component:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(hobo::Element, hobo::Container, hobo::EventTarget)]
pub struct Input {
	element: cmp::Div,
	pub input: cmp::Input,
}

impl Input {
	pub fn new(caption_text: &amp;str, svg: Option&lt;cmp::Svg&gt;) -&gt; Self {
		let input = cmp::input()
			.attr(web_str::r#type(), web_str::text())
			.class(css::class! {
				// some style
			});

		let caption_text = cmp::div()
			.text(caption_text)
			.class(css::class! {
				// some style
			});

		let mut element = cmp::div()
			.child_ref(&amp;input)
			.child(caption_text);

		if let Some(svg) = svg {
			element.add_child(
				svg.class(css::class! {
					// some style
				})
			);
		}

		Self { element, input }
			.class(css::style! {
				// some style
			})
	}
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#difference-between-childadd_child-and-child_refadd_child_ref" id="difference-between-childadd_child-and-child_refadd_child_ref">Difference between <code>.child()</code>/<code>.add_child()</code> and <code>.child_ref()</code>/<code>.add_child_ref()</code></a></h3>
<p><code>.child()</code> takes a component by value, while <code>.child_ref()</code> by reference. Taking a component by value ties that component's lifespan to the lifespan of its container, in other words when the container will be dropped - the child will as well. However, sometimes you need to mount a component first but later capture it in an event handler, expose it to parent or replace it later. In those cases, ownership of the component must be passed elsewhere.</p>
<h3><a class="header" href="#why-is-class-called-after-self--element-input--and-not-while-element-is-being-constructed" id="why-is-class-called-after-self--element-input--and-not-while-element-is-being-constructed">Why is <code>.class()</code> called after <code>Self { element, input }</code> and not while <code>element</code> is being constructed?</a></h3>
<p>Class assignment in <code>hobo</code> is double duty - apart from applying the style, it also assigns class that's generated from the component's type so it can later be selected with a <code>.[T]</code> selector. If class where assigned at the <code>element</code>'s construction site - it would get the class of type for <code>cmp::Div</code> (alias for <code>hobo::BasicElement&lt;web_sys::HtmlDivElement&gt;</code>) rather than <code>Input</code>.</p>
<h3><a class="header" href="#chaining-vs-non-chaining-syntax" id="chaining-vs-non-chaining-syntax">Chaining vs non-chaining syntax</a></h3>
<p>Most functions have a chaining syntax, handy when constructing the component, and also non-chaining syntax for use in loops or other contexts. The convention is <code>.&lt;foo&gt;</code> for chaining and <code>.add_&lt;foo&gt;</code> for non-chaining. This goes against the more common Rust convention of <code>.with_&lt;foo&gt;</code> being the chaining syntax, this is because most code will be simple elements constructed in bulk, so most of these calls will be chaining so a shorter name is preferred.</p>
<ul>
<li><code>.child()</code>/<code>.child_ref()</code> vs <code>.add_child()</code>/<code>.add_child_ref()</code></li>
<li><code>.class()</code> vs <code>.set_class()</code></li>
<li><code>.style()</code> vs <code>.set_style()</code></li>
<li><code>.attr()</code>/<code>.bool_attr()</code> vs <code>.set_attr()</code>/<code>.set_bool_attr()</code></li>
<li><code>.&lt;event&gt;()</code>/<code>.&lt;event&gt;_mut()</code> vs <code>.add_&lt;event&gt;()</code>/<code>.add_&lt;event&gt;_mut()</code></li>
<li><code>.text()</code> vs <code>.set_text()</code></li>
</ul>
<h1><a class="header" href="#other-utilities" id="other-utilities">Other utilities</a></h1>
<p>This chapter outlines useful helpers for common tasks that didn't make it into the core.</p>
<h1><a class="header" href="#web_str" id="web_str">web_str</a></h1>
<p>The <code>web_str</code> module is just a bunch of commonly used interned strings. It includes all element names, all event names and a bunch of common attributes and values like <code>class</code>, <code>min</code>, <code>max</code>, <code>checked</code>, <code>href</code>, <code>readonly</code>, etc. If something is missing - PRs welcome!</p>
<p>To read more about what is string interning and why is it useful: <a href="https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/fn.intern.html">wasm-bindgen docs</a></p>
<h1><a class="header" href="#slot" id="slot">Slot</a></h1>
<p><code>Slot</code> is essentially a <code>Rc&lt;RefCell&lt;Box&lt;dyn Element&gt;&gt;</code> with a more convenient constructor. It is useful if you have a component of unknown type and that you wish to replace time to time, e.g. main page container, a table cell or if there's a lot of variant types and you don't want to make a tuple because you don't particularly care about preserving the type information.</p>
<h1><a class="header" href="#recipes" id="recipes">Recipes</a></h1>
<p>This chapter outlines common idioms and patterns.</p>
<h1><a class="header" href="#elements-that-change" id="elements-that-change">Elements that change</a></h1>
<p>Since there's no VDOM, rebuilding the DOM is done manually by literally rebuilding the altered parts. It is on the developer to minimize this to maintain element focus, scroll position, performance, etc. The same goes for styling - any complex modification is best expressed as recreating the whole style.</p>
<!-- TODO: provide an example-->
<h1><a class="header" href="#svgs" id="svgs">SVGs</a></h1>
<p>To conveniently serve SVGs inline without having to rewrite your icons in <code>hobo</code>'s syntax, <code>hobo::BasicElement&lt;web_sys::SvgElement&gt;</code> can be converted from a <code>roxmltree::Document</code> and then cloned with <code>hobo::BasicElement::clone_html</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! svg {
	($($name:ident =&gt; $address:expr),*$(,)*) =&gt; {paste::item!{
		thread_local!{$(
			static [&lt;$name _static&gt;]: hobo::BasicElement&lt;hobo::web_sys::SvgElement&gt; =
				roxmltree::Document::parse(include_str!($address)).unwrap().into();
		)*}

		$(
			#[must_use]
			pub fn $name() -&gt; hobo::BasicElement&lt;hobo::web_sys::SvgElement&gt; {
				[&lt;$name _static&gt;].with(hobo::BasicElement::clone_html)
			}
		)*
	}};
}

svg![
	plus_circle =&gt; r&quot;images/plus-circle.svg&quot;,
	minus_circle =&gt; r&quot;images/minus-circle.svg&quot;,
	mail =&gt; r&quot;images/mail.svg&quot;,
];
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#constructing-inline-svgs" id="constructing-inline-svgs">Constructing inline SVGs</a></h2>
<p>Of course, if you need to algorithmically construct an svg, such as if you're making a chart, you can do that too:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut svg = cmp::svg()
	.attr(&quot;viewBox&quot;, &quot;-1 -1 2 2&quot;)
	.child(cmp::circle()
		.attr(&quot;cx&quot;, &quot;0&quot;)
		.attr(&quot;cy&quot;, &quot;0&quot;)
		.attr(&quot;r&quot;, &quot;1&quot;)
		.class(css::class!(
			css::fill!(...colors::gray6),
		))
	);
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
