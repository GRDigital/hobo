<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>hobo book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="hobo is a Rust frontend framework">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> hobo</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="basic-concepts.html"><strong aria-hidden="true">3.</strong> Core Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic-concepts/entities-components-resources.html"><strong aria-hidden="true">3.1.</strong> Entities, Components (and Resources)</a></li><li class="chapter-item expanded "><a href="basic-concepts/hobo-create.html"><strong aria-hidden="true">3.2.</strong> hobo::create</a></li><li class="chapter-item expanded "><a href="basic-concepts/children-and-parent.html"><strong aria-hidden="true">3.3.</strong> Children and Parent</a></li><li class="chapter-item expanded "><a href="basic-concepts/removing-and-replacing-elements.html"><strong aria-hidden="true">3.4.</strong> Removing and replacing elements</a></li><li class="chapter-item expanded "><a href="basic-concepts/dom-events.html"><strong aria-hidden="true">3.5.</strong> DOM Events and EventHandlerCallback</a></li><li class="chapter-item expanded "><a href="basic-concepts/borrowing-and-storage.html"><strong aria-hidden="true">3.6.</strong> Borrowing and Storage</a></li></ol></li><li class="chapter-item expanded "><a href="styling.html"><strong aria-hidden="true">4.</strong> Styling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="styling/selector.html"><strong aria-hidden="true">4.1.</strong> Selector</a></li><li class="chapter-item expanded "><a href="styling/property.html"><strong aria-hidden="true">4.2.</strong> Property</a></li><li class="chapter-item expanded "><a href="styling/at-rules.html"><strong aria-hidden="true">4.3.</strong> @-rules</a></li><li class="chapter-item expanded "><a href="styling/colors.html"><strong aria-hidden="true">4.4.</strong> Colors</a></li><li class="chapter-item expanded "><a href="styling/every-way-to-make-a-class.html"><strong aria-hidden="true">4.5.</strong> Every way to make a class</a></li></ol></li><li class="chapter-item expanded "><a href="state.html"><strong aria-hidden="true">5.</strong> Managing state and relations with Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="state/queries.html"><strong aria-hidden="true">5.1.</strong> Queries</a></li><li class="chapter-item expanded "><a href="state/signals.html"><strong aria-hidden="true">5.2.</strong> Signals</a></li></ol></li><li class="chapter-item expanded "><a href="building-the-dom.html"><strong aria-hidden="true">6.</strong> Building the DOM</a></li><li class="chapter-item expanded "><a href="utilities.html"><strong aria-hidden="true">7.</strong> Other utilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="utilities/web_str.html"><strong aria-hidden="true">7.1.</strong> web_str</a></li><li class="chapter-item expanded "><a href="utilities/events.html"><strong aria-hidden="true">7.2.</strong> Events</a></li></ol></li><li class="chapter-item expanded "><a href="recipes.html"><strong aria-hidden="true">8.</strong> Recipes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="recipes/logging.html"><strong aria-hidden="true">8.1.</strong> Logging</a></li><li class="chapter-item expanded "><a href="recipes/elements-that-change.html"><strong aria-hidden="true">8.2.</strong> Elements that change</a></li><li class="chapter-item expanded "><a href="recipes/svgs.html"><strong aria-hidden="true">8.3.</strong> SVGs</a></li><li class="chapter-item expanded "><a href="recipes/async-and-is-dead.html"><strong aria-hidden="true">8.4.</strong> Async and .is_dead()</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">hobo book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hobo"><a class="header" href="#hobo">hobo</a></h1>
<p><a href="https://crates.io/crates/hobo"><img alt="Crate Info" src="https://img.shields.io/crates/v/hobo.svg"/></a>
<a href="https://docs.rs/hobo/"><img alt="API Docs" src="https://img.shields.io/badge/docs.rs-hobo-yellow"/></a></p>
<p><strong>hobo</strong> is an opinionated, batteries-included Rust frontend framework. Works on <strong>stable Rust</strong>.<br />
<strong>STILL WIP</strong> although used in production by <a href="https://grdigital.co.uk/">GR Digital</a>.<br />
<a href="https://grdigital.github.io/hobo/index.html">Check out the Book</a>!</p>
<h3 id="notable-features"><a class="header" href="#notable-features">Notable features:</a></h3>
<ul>
<li><strong>no virtual DOM</strong> - html elements are just components added to entities and can be accessed directly via <code>web_sys::HtmlElement</code></li>
<li>no Model-View-Update (aka Elm architecture) - state management is manual, usually via Entity-Component relations</li>
<li>no HTML macros - just Rust functions</li>
<li>built-in macro-based styling, kind of like CSS-in-JS except it's just Rust</li>
<li><strong>reactivity support</strong> via <a href="https://github.com/Pauan/rust-signals">futures-signals</a></li>
<li>Entity-Component based approach allowing flexible state propagation and cohesion between elements without coupling or a need for global store or state</li>
</ul>
<h3 id="sneak-peek"><a class="header" href="#sneak-peek">Sneak peek:</a></h3>
<pre><code class="language-rust noplaypen">pub use hobo::{
    prelude::*,
    create as e,
    signals::signal::{Mutable, SignalExt}
};

fn counter() -&gt; impl hobo::AsElement {
    let counter = Mutable::new(0);

    e::div()
        .class((
            css::display!(flex),
            css::flex_direction!(column),
            css::width!(400 px),
        ))
        .child(e::div()
            .text_signal(counter.signal().map(|value| {
                format!(&quot;Counter value is: {value}&quot;)
            }))
        )
        .child(e::button()
            .text(&quot;increment&quot;)
            .on_click(move |_| *counter.lock_mut() += 1)
        )
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Here's a basic counter component:</p>
<pre><code class="language-rust noplaypen">pub use hobo::{
    prelude::*, 
    create as e,
    signals::signal::{Mutable, SignalExt}
}

// &lt;div class=&quot;s-f4d1763947b5e1ff&quot;&gt;
//   &lt;div&gt;Counter value is: 0&lt;/div&gt;
//   &lt;button&gt;increment&lt;/button&gt;
//   &lt;button&gt;decrement&lt;/button&gt;
// &lt;/div&gt;

fn counter() -&gt; impl hobo::AsElement {
    let counter_value = Mutable::new(0_i32);

    e::div()
        .class((
            // enum-like properties can also be set like `css::Display::Flex`
            css::display!(flex),
            css::width!(400 px),
            // #AA0000FF or #AA0000 or #A00 in normal css
            css::background_color!(rgb 0xAA_00_00),
            css::align_items!(center),
            css::justify_content!(space-between),
        ))
        .child(e::div()
            .text_signal(counter_value.signal().map(|value| {
                format!(&quot;Counter value is: {}&quot;, value)
            }))
        )
        .component(counter_value)
        .with(move |&amp;counter_div| counter_div
            .child(e::button()
                .class(css::style!(
                    // .&amp; is replaced with &quot;current&quot; class name, similar to SASS
                    // or styled-components
                    .&amp; {
                        // shortcut for padding-left and padding-right
                        css::padding_horizontal!(16 px),
                        css::background_color!(css::color::PALEVIOLETRED),
                    }

                    .&amp;:hover {
                        css::background_color!(css::color::GREEN),
                    }
                ))
                .text(&quot;increment&quot;)
                .on_click(move |_| {
                    *counter_div.get_cmp::&lt;Mutable&lt;i32&gt;&gt;().lock_mut() += 1;
                })
            )
            .add_child(e::button() // same as .child but non-chaining
                // since this style is identical to the one above it - the class will be
                // reused to avoid copypasting - the button generating code can be
                // moved into a function or maybe just the code that defines the style
                .class(css::style!(
                    .&amp; {
                        css::padding_horizontal!(16 px),
                        css::background_color!(css::color::PALEVIOLETRED),
                    }

                    .&amp;:hover {
                        css::background_color!(css::color::GREEN),
                    }
                ))
                .text(&quot;decrement&quot;)
                .on_click(move |_| {
                    *counter_div.get_cmp::&lt;Mutable&lt;i32&gt;&gt;().lock_mut() -= 1;
                })
            )
        )
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>This chapter outlines core types, traits and styling facilities that <code>hobo</code> employs.</p>
<p>Some note on terms used:</p>
<ul>
<li><strong>Entity</strong>: a (usually) copyable id, that has components associated with it</li>
<li><strong>Element</strong>: not to be confused with HTML elements, an Entity that has HTML or SVG components (which represent HTML elements) associated with it and so can have children, class, attributes, etc</li>
<li><strong>Component</strong>: any kind of data that may be associated with an Entity</li>
<li><strong>Mutable</strong>: not to be confused with Rust's notion of mutability, a type from <code>futures_signals</code> that can be used to produce signals</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entities-components-and-resources"><a class="header" href="#entities-components-and-resources">Entities, Components (and Resources)</a></h1>
<p>The backbone of the framework is the Entity-Component approach of associating data. <strong>Entities</strong> are just incrementing <code>u64</code>s under the hood, they carry no data.</p>
<p><strong>Elements</strong> are no different in this regard, the only difference is that <strong>Elements</strong> have a compile time promise that these entities have <code>web_sys::Node</code>, <code>web_sys::Element</code>, <code>web_sys::EventTarget</code> and one of <code>web_sys::HtmlElement</code> or <code>web_sys::SvgElement</code> attached to them. As a consequence, these <strong>Entities</strong> can get styled, get attributes and compose into DOM.</p>
<p><strong>Resources</strong> are same as <strong>Components</strong> but they are accessible globally, they aren't associated with any entity. Only one instance of a type of <strong>Resource</strong> can exist at any time, in this way they are similar to singletons from other programming languages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hobocreate"><a class="header" href="#hobocreate"><code>hobo::create</code></a></h1>
<p>This module has a <code>snake_case</code> function which returns a corresponding <code>PascalCase</code> concrete type that implements <strong>AsElement</strong>.</p>
<pre><code class="language-rust noplaypen">let some_div: hobo::create::Div = hobo::create::div();
</code></pre>
<p><strong>Element</strong> has methods that aren't available on regular entities.</p>
<h2 id="hoboaselement-and-hoboasentity"><a class="header" href="#hoboaselement-and-hoboasentity"><code>hobo::AsElement</code> and <code>hobo::AsEntity</code></a></h2>
<p>Sometimes it's useful to have custom types so you can have some special capabilities on your <strong>Entities</strong> or <strong>Elements</strong>.</p>
<pre><code class="language-rust noplaypen">#[derive(hobo::AsElement, Clone, Copy /* etc */)]
struct Checkbox(hobo::create::Div);

// just an example of why you might want to do this
impl Checkbox {
	fn is_checked(&amp;self) -&gt; bool {
		*self.get_cmp::&lt;bool&gt;()
	}

	fn set_checked(&amp;self, checked: bool) {
		*self.get_cmp_mut_or_default::&lt;bool&gt;() = checked;
	}

	// probably etc methods
}
</code></pre>
<p>The <code>hobo::AsElement</code> derive macro expects either a tuple struct or a regular struct where the <strong>Entity</strong> field is named <code>element</code> e.g.</p>
<pre><code class="language-rust noplaypen">#[derive(hobo::AsElement, Clone, Copy /* etc */)]
struct CustomSelect {
	element: hobo::create::Select,
	// etc
}
</code></pre>
<h2 id="element-and-type-erasure"><a class="header" href="#element-and-type-erasure"><code>Element</code> and type erasure</a></h2>
<p>It's often useful to mix different types of <strong>Elements</strong>, for example:</p>
<pre><code class="language-rust noplaypen">fn content() -&gt; impl hobo::AsElement {
	match tab {
		Tab::Main =&gt; main_page(), // hobo::create::Div
		Tab::Blogpost =&gt; article(), // hobo::create::Article
		// etc
	}
}
</code></pre>
<p>This won't compile, but the distinction between types in this case isn't useful. So we can erase the concrete types and get the general <code>Element</code>:</p>
<pre><code class="language-rust noplaypen">fn content() -&gt; impl hobo::Element {
	match tab {
		Tab::Main =&gt; main_page().erase(), // hobo::Element
		Tab::Blogpost =&gt; article().erase(), // hobo::Element
		// etc
	}
}
</code></pre>
<p>If you have a regular <strong>Entity</strong> or something that at least implements <code>hobo::AsEntity</code> - you can recover <strong>Element</strong> capabilities by just constructing a <code>Element</code>:</p>
<pre><code class="language-rust noplaypen">let elem = hobo::Element(some_entity);
</code></pre>
<p>This pattern is often useful when using queries to find elements, as queries often return entities (more on them in <a href="basic-concepts/../state/queries.html">queries</a>)</p>
<pre><code class="language-rust noplaypen">let (entity, _) = hobo::find_ond::&lt;Entity, With&lt;ComponentFoo&gt;&gt;();
// We know that this entity is an Input element we've made,
// but we need it's type to be an Input, not Entity,
// to e.g. access it's value via the get/set_value methods
let input_element = hobo::create::Input(entity);
let input_value = input_element.get_value();
</code></pre>
<p>One can think of it almost as casting - we're fetching an entity which we, as the writer, know is an Input - however, we need to &quot;cast&quot; this Entity to an Input type in order to access Input capabilities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="children-and-parent"><a class="header" href="#children-and-parent">Children and Parent</a></h1>
<p>Hierarchical DOM relations in <code>hobo</code> are maintained through regular <strong>Components</strong> - <code>hobo::Children</code> and <code>hobo::Parent</code>.</p>
<p>Usually you won't have to care about it since <code>.add_child()</code> (and the like) and <code>.remove()</code> already take care of updating <code>Children</code> and <code>Parent</code> components of affected entities.</p>
<p><code>hobo::Children</code> is just a <code>Vec</code> of <code>hobo::Entity</code>, <code>hobo::Parent</code> is a newtype wrapper over <code>hobo::Entity</code> as well. If you have an <strong>Element</strong> and you want to operate on all (or some) of its children - it's as simple as:</p>
<pre><code class="language-rust noplaypen">let children = foo.get_cmp::&lt;hobo::Children&gt;()
    .iter()
    .map(|entity| hobo::SomeElement(entity));

for child in children {
    child.set_text(&quot;hello from hobo!&quot;);
}
</code></pre>
<p>It is possible to detach a child from its parent to reattach it to a different <strong>Element</strong> later, but it's not as simple as removing <code>hobo::Parent</code> and fixing up <code>hobo::Children</code> of the parent entity since the DOM has to be modified as well. A convenient method exists however:</p>
<pre><code class="language-rust noplaypen">// this removes parent and fixes children component in parent as well
some_child.leave_parent();
new_parent.add_child(some_child);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="removing-and-replacing-elements"><a class="header" href="#removing-and-replacing-elements">Removing and replacing elements</a></h1>
<p>Removing an <strong>Element</strong> (or an <strong>Entity</strong>) is as simple as calling <code>.remove()</code>. The method will recursively remove all entities in <code>hobo::Children</code> of the entity to be removed as well. All components that have been added to entities that are being removed are also removed and dropped.</p>
<p>It is possible to replace an <strong>Element</strong> inplace, fixing up the <code>hobo::Children</code> in parent entity as well. This, however, replaces it with a new <strong>Entity</strong> so if a copy is held somewhere - it won't be valid anymore, so take care.</p>
<pre><code class="language-rust noplaypen">let new_element = hobo::create::div();
old_element.replace_with(new_element);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dom-events-and-eventhandlercallback"><a class="header" href="#dom-events-and-eventhandlercallback">DOM Events and EventHandlerCallback</a></h1>
<p><strong>Elements</strong> have methods that allow reacting to DOM Events. All of these methods are <code>snake_case</code> in the form of <code>.on_&lt;name&gt;</code> e.g. <code>.on_click</code> or <code>.on_touch_start</code>. Not all possible events are supported currently, but adding new ones is very easy - PRs welcome!</p>
<pre><code class="language-rust noplaypen">element
    .on_click(move |_| { // the argument here is web_sys::MouseEvent
        element.set_text(&quot;I am clicked!&quot;);
    })
</code></pre>
<p>These methods operate by means of, unsurprisingly, adding or modifying a <strong>Component</strong> on the element. The callback itself gets wrapped in <code>hobo::dom_events::EventHandlerCallback</code>, which will unsubscribe from DOM when dropped. A <strong>Component</strong> with a <code>Vec&lt;EventHandlerCallback&gt;</code> is created unless it already exists, then the just created <code>EventHandlerCallback</code> is just pushed into it.</p>
<p>It's possible to manage subscribing/unsubscribing manually by calling the functions on raw <code>web_sys::HtmlElement</code>s. For example, when you're doing some kind of a slider and you want some logic in <code>on_mouse_move</code> even if the mouse leaves the element:</p>
<pre><code class="language-rust noplaypen">element
    .on_mouse_down(move |_| {
        // &quot;drag&quot; start
    })
    .component((
        web_sys::window().unwrap().on_mouse_move(move |e| {
            // if dragging, run some dragging logic even once mouse leaves the element
        }),
        web_sys::window().unwrap().on_mouse_up(move |e| {
            // &quot;drag&quot; stop
        }),
    ))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing-and-storage"><a class="header" href="#borrowing-and-storage">Borrowing and Storage</a></h1>
<p>Components for entities are stored in a simple map - <code>HashMap&lt;Entity, Component&gt;</code> (see, <code>hobo::storage::SimpleStorage</code>).</p>
<p>(This also makes searching for components via <code>hobo::find_one</code> <em>very</em> cheap).</p>
<p>Rust's ownership rules ensure that a mutable borrow is exclusive, which means that we cannot have mutable references to components while immutable ones exists (or vice-versa).
Here's an example of how this affects hobo:</p>
<pre><code class="language-rust noplaypen">// src\example_file.rs

mod example_module {
    pub use hobo::{prelude::*, create as e};

    struct Foo;

    pub fn test() -&gt; impl hobo::AsElement {
        e::div()
            .component(Foo)
            .with(|&amp;element| {
                // Ok
                let foo1 = element.get_cmp::&lt;Foo&gt;();
                // Still ok
                let foo2 = element.get_cmp::&lt;Foo&gt;();
                // Panic!
                let foo3 = element.get_cmp_mut::&lt;Foo&gt;();
            })
    }
}
</code></pre>
<p>This, of course, also applies to queries/find/etc.</p>
<p>This can be a bit tricky to debug in Wasm, which is why when compiling in debug mode, hobo will display the following helpful message in the browser's console if a borrow-related runtime panic is encountered:</p>
<pre><code>panicked at ''already borrowed': Trying to mutably borrow `example_module::Foo`    
storage at `src\example_file.rs:16:50` while other borrows to it already exist:

(mut) src\example_file.rs:16:50
      src\example_flib.rs:14:50
      src\example_flib.rs:12:50
</code></pre>
<p>This will list <strong>only</strong> the currently active borrows, as well as the mutable one, descending in order of access.</p>
<p>(Every type we store as a component will have it's own storage, so it's fine to mutably borrow storages of different types.)</p>
<p>As an example of where this could arise as an issue, imagine the following situation:</p>
<p>We want to replace an element with a new one, using some data we stored in it.</p>
<pre><code class="language-rust noplaypen">struct SomeData {
    big_data: u64,
};

pub fn update_element(old_element: impl hobo::AsElement + Copy) {
    let some_data = old_element.get_cmp::&lt;SomeData&gt;();

    let new_element = process_data_and_return_div(some_data);
    
    // Runtime panic!
    old_element.replace_with(new_element);
}
</code></pre>
<p>This will panic at runtime - this is because when we delete the old element (via replace) we need to mutably borrow the storage to all of it's components, in order to delete them too.
However, we are already holding a reference to one of the components.</p>
<p>The way to circumvent this would be similar to how one would for any other ownership issue:</p>
<p>You can drop the guard, ensuring that no references conflict:</p>
<pre><code class="language-rust noplaypen">pub fn update_element(old_element: impl hobo::AsElement + Copy) {
    let some_data = old_element.get_cmp::&lt;SomeData&gt;();

    let new_element = process_data_and_return_div(some_data);
    
    drop(some_data);

    old_element.replace_with(new_element);
}
</code></pre>
<p>Or, you can clone the value:</p>
<pre><code class="language-rust noplaypen">#[derive(Clone)]
struct SomeData {
    big_data: u64,
};

pub fn update_element(element: impl hobo::AsElement + Copy) {
    let some_data = old_element.get_cmp::&lt;SomeData&gt;().clone();

    let new_element = process_data_and_return_div(&amp;some_data);
    
    old_element.replace_with(new_element);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="styling-facilities"><a class="header" href="#styling-facilities">Styling facilities</a></h1>
<p>Most <strong>Elements</strong> will be styled with either <code>.class()</code> or <code>.style()</code> functions, where either <code>css::style!()</code> or a property tuple will be used.</p>
<ul>
<li><code>.style()</code> and <code>.set_style()</code> use the <code>style</code> attribute, which can only take a bunch of properties without any selectors, so a property tuple is used.</li>
<li><code>.class()</code>, <code>.set_class()</code> and <code>tagged</code> or <code>typed</code> variants use the <code>class</code> attribute:</li>
</ul>
<p>For example, here's a style:</p>
<pre><code class="language-rust noplaypen">hobo::create::div()
    .class(css::style!(
        .&amp; {
            css::height!(393 px),
            css::Display::Flex, // can also be `css::display!(flex)`
            css::AlignItems::Center,
            css::Position::Relative,
        }

        .&amp; &gt; svg {
            css::width!(12 px),
            css::height!(100%),
            css::Cursor::Pointer,
            css::flex_shrink!(0),
            css::UserSelect::None,
        }

        .&amp; &gt; :not(:nth_child(0, 1)) { // nth_child will convert to An+B syntax
            css::z_index!(200),
        }

        .&amp; &gt; div:not(:nth_child(0, 1)) {
            css::width!(17.5%),
            css::height!(100%),
            css::Display::Flex,
            css::AlignItems::Center,
        }

        // doubling up on the class name increases specificity
        .&amp;.&amp; &gt; :nth_child(0, 5) { 
            css::width!(30%),
        }

        .&amp; &gt; *:nth_child(0, 3) &gt; img,
        .&amp; &gt; *:nth_child(0, 4) &gt; img,
        .&amp; &gt; svg:last_child {
            css::TransformFunction::TranslateX(css::unit!(50%)),
        }

        .&amp; &gt;&gt; img { // this is same as `.&amp; img` selector in css
            css::height!(100%),
        }
    ))
</code></pre>
<p>Property tuple example:</p>
<pre><code class="language-rust noplaypen">    hobo::create::div()
        .style((
            // Shortcut for same width and height
            css::size!(12 px),
            css::Display::Flex,
        ))
</code></pre>
<p>If only a single property is used, one can ommit the tuple:</p>
<pre><code class="language-rust noplaypen">    hobo::create::div()
        .class(css::Display::Flex)
</code></pre>
<blockquote>
<p><strong>Chaining vs non-chaining syntax:</strong> <code>.style()</code> is the chaining syntax, <code>.set_style()</code> is the non-chaining alternative. Similarly, <code>.class()</code> and <code>.set_class()</code>. More about chaining vs non-chaining syntax in <a href="./building-the-dom.html#chaining-vs-non-chaining-syntax">Building the DOM</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selector"><a class="header" href="#selector">Selector</a></h1>
<p>hobo selectors mirror css selectors with minor changes, most notably:</p>
<ul>
<li>descendant selectors like <code>div a</code> become <code>div &gt;&gt; a</code> because Rust doesn't have semantic whitespaces.
<ul>
<li>selectors like <code>div.active</code> work mostly the same (except have to be written like <code>div.(&quot;active&quot;)</code> or <code>div .(&quot;active&quot;)</code>)</li>
</ul>
</li>
<li>ids have to be written like <code>#(&quot;foo-1234&quot;)</code></li>
<li>pseudo-classes use <code>_</code> instead of <code>-</code> and must always use single colon syntax, e.g. <code>:active</code> or <code>:last_child</code>
<ul>
<li>there's an escape hatch in <code>:raw(&quot;-webkit-prop&quot;.to_string())</code> for browser-specific or other weird things</li>
</ul>
</li>
<li>pseudo-elements use <code>_</code> instead of <code>-</code> and must always use double colon syntax, e.g. <code>::after</code> or <code>::first_line</code></li>
</ul>
<p>There are also several additions:</p>
<ul>
<li><code>.&amp;</code> will be replaced at runtime with the name of a class, which will be generated from the rules in the style it belongs to
<ul>
<li>in other words, it's similar to <code>&amp;</code> in SASS or <code>styled-components</code></li>
</ul>
</li>
<li><code>.[T]</code> where <code>T</code> is some marker type will be replaced with the generated classname for the type <code>T</code> so you could select based on custom marker type.</li>
</ul>
<pre><code class="language-rust noplaypen">use hobo::create as e;

struct ButtonMarker;

e::div()
    .class(css::style!(
        .&amp; &gt;&gt; .[ButtonMarker] {
            css::cursor!(pointer),
        }
    ))
    .child(e::div()
        .mark::&lt;ButtonMarker&gt;()
        .text(&quot;button 1&quot;)
    )
    .child(e::div()
        .mark::&lt;ButtonMarker&gt;()
        .text(&quot;button 2&quot;)
    )
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property"><a class="header" href="#property">Property</a></h1>
<p>Most css properties will be expressed as tuples of anything that implements <code>hobo::css::AppendProperty</code>, which includes:</p>
<ul>
<li><code>css::Property</code> such as created by the <code>css::&lt;prop&gt;()</code> family of macros (e.g. <code>css::width!()</code>, <code>css::flex_shrink!()</code>, etc)</li>
<li><code>Vec&lt;css::Property&gt;</code></li>
<li><code>()</code></li>
<li><code>&amp;'static str</code> and <code>String</code> as escape hatches</li>
<li><code>FnOnce(&amp;mut Vec&lt;Property&gt;)</code> for rare complex logic</li>
<li>Other tuples of things that implement <code>hobo::css::AppendProperty</code></li>
<li>Enum-like property variants e.g. <code>css::Display::Flex</code> or <code>css::TextDecorationStyle::Solid</code></li>
</ul>
<p>Conditional property inclusion could be expressed as different <code>Vec&lt;css::Property&gt;</code> where one is empty, e.g.</p>
<pre><code class="language-rust noplaypen">(
    css::display!(flex),
    if active {
        vec![css::background_color!(0x00_00_FF_FF)],
    } else {
        vec![],
    },
)
</code></pre>
<p>Or alternatively, by leveraging <code>FnOnce</code></p>
<pre><code class="language-rust noplaypen">(
    css::display!(flex),
    move |props| if active { props.push(css::background_color!(0x00_00_FF_FF)); },
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rules"><a class="header" href="#-rules">@-rules</a></h1>
<p>Right now hobo only supports <code>@font-face</code> and a subset of <code>@media</code></p>
<h1 id="font-face"><a class="header" href="#font-face"><code>@font-face</code></a></h1>
<p>The block following <code>@font-face</code> is passed as initialization for <code>css::font_face::FontFace</code>. Check out the <a href="https://docs.rs/hobo_css/latest/hobo_css/font_face/struct.FontFace.html">docs</a>.<br />
It looks something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>@font-face {
    src: vec![(&quot;https://fonts.gstatic.com/.../....woff2&quot;.into(), Some(Format::Woff2))],
    font_family: &quot;Encode Sans&quot;.into(),
    font_weight: (Weight::Number(400), None),
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="media"><a class="header" href="#media"><code>@media</code></a></h1>
<p>The syntax is different to <code>@media</code> rules in css:</p>
<ul>
<li>specifying media type is not optional</li>
<li><code>!</code> instead of <code>not</code></li>
<li><code>CamelCase</code> instead of <code>kebab-case</code></li>
<li><code>&amp;&amp;</code> instead of <code>and</code></li>
<li>no grouping rules in <code>not</code> clauses</li>
</ul>
<p>So these two would be equivalent:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>@media All &amp;&amp; MaxWidth(css::unit!(1023 px)) {
    html {
        css::background_color!(rgb 0xFF_00_00),
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-css">@media all and (max-width: 1023px) {
    html {
        background-color: #FF0000;
    }
}
</code></pre>
<p>Support for <code>@keyframes</code> and <code>@page</code> is planned.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="colors"><a class="header" href="#colors">Colors</a></h1>
<p>Color property macros like <code>css::color!</code> and <code>css::fill!</code> and the like have shorthands for full-alpha RGB colors as well as grayscale.</p>
<pre><code class="language-rust noplaypen">css::color!(rgb 0xFF_00_00), // same as css::color!(0xFF_00_00_FF) or #F00 in css
css::color!(gray 0xAD), // same as css::color!(0xAD_AD_AD_FF) or #ADADAD in css
</code></pre>
<p>Css named colors also can be used</p>
<pre><code class="language-rust noplaypen">css::color!(css::color::PALEVIOLETRED),
css::color!(css::color::GREEN),
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="every-way-to-make-a-class"><a class="header" href="#every-way-to-make-a-class">Every way to make a class</a></h1>
<p>Apart from regular <code>.class()</code>/<code>.set_class()</code> options there's several others:</p>
<ul>
<li><code>.mark::&lt;T&gt;()</code>/<code>.unmark::&lt;T&gt;()</code> - can generate classes from any type for targeted selection. </li>
</ul>
<pre><code class="language-rust noplaypen">use hobo::create as e;

struct ButtonMarker;

e::div()
    .class(css::style!(
        .&amp; &gt;&gt; .[ButtonMarker] {
            css::cursor!(pointer),
        }
    ))
    .child(e::div()
        .mark::&lt;ButtonMarker&gt;()
        .text(&quot;button 1&quot;)
    )
    .child(e::div()
        .mark::&lt;ButtonMarker&gt;()
        .text(&quot;button 2&quot;)
    )
</code></pre>
<p>Every call to <code>.class()</code>/<code>.set_class()</code> will append a new class - if you want to override an existing one, there are two options:</p>
<ul>
<li><code>.set_class_typed::&lt;Type&gt;(style)</code> - generates a tag from a <code>Type</code>. This is usually the preferred method, in the rare case that you need to override classes.</li>
</ul>
<pre><code class="language-rust noplaypen">use hobo::create as e;

struct Flexible;

e::div()
    .class((css::display!(flex), css::background_color!(css::color::RED)))
    .class_typed::&lt;Flexible&gt;((
        css::flex_direction!(row),
        css::width!(100 px),
    ))
    .with(|&amp;element| element.add_on_click(move |_| {
        element
            .set_class_typed::&lt;Flexible&gt;((
                css::flex_direction!(column),
                css::height!(100 px),
            ))
    }))
</code></pre>
<ul>
<li><code>.set_class_tagged::&lt;Tag: Hash&gt;(tag, style)</code> - Similar to <code>.set_class_tagged</code>, but uses an instance of a type rather than <code>Type</code>. The regular <code>.class()</code> method uses this internally with just an incrementing <code>u64</code> for a tag.</li>
</ul>
<pre><code class="language-rust noplaypen">use hobo::create as e;

e::div()
    .class(css::display!(flex))
    .class_tagged(&quot;Flexible&quot;, (
        css::flex_direction!(row),
        css::width!(100 px),
    ))
    .on_click(|&amp;element| {
        element
            .set_class_tagged(&quot;Flexible&quot;, (
                css::flex_direction!(column),
                css::height!(100 px),
            ))
    })
</code></pre>
<p>Prefer using this over <code>.set_class_typed</code> if your tag is computed at runtime.</p>
<ul>
<li>signals - you can have your classes be set reactively, in response to some changes in a <code>Mutable</code>. This is the preferred method for anything reactive, such as switching between themes:</li>
</ul>
<pre><code class="language-rust noplaypen">enum Theme {
    Light,
    Dark,
}

let theme = Mutable::new(Theme::Light);

e::div()
    .class_typed_signal::&lt;Theme, _, _&gt;(theme.signal().map(|theme| {
        match theme {
            Theme::Light =&gt; css::background_color!(css::color::WHITE),
            Theme::Dark =&gt; css::background_color!(css::color::BLACK),
        }
    }))
    .component(theme)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-state-and-relations-with-components"><a class="header" href="#managing-state-and-relations-with-components">Managing state and relations with <strong>Components</strong></a></h1>
<p>The next few chapters will outline how hobo deals with shared state.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>Queries allow finding individual <strong>Entities</strong> or collections of <strong>Entities</strong>. Best shown by examples:</p>
<pre><code class="language-rust noplaypen">struct Foo {
    // some fields
}

// find the first (presumably only) entity with some component Foo
let (entity, _) = hobo::find_one::&lt;(Entity, With&lt;Foo&gt;)&gt;();
let element = hobo::Element(entity);
element.set_text(&quot;This entity has Foo&quot;);
</code></pre>
<pre><code class="language-rust noplaypen">struct Frobnicator {
    num_fraculations: u32,
    // other fields
}

// find all entities with a Frobnicator component and mutate it
// perhaps as a result of some combined transformation
for frobnicator in hobo::find::&lt;&amp;mut Frobnicator&gt;() {
    frobnicator.num_fraculations += 1;
}
</code></pre>
<p>Queries are tuples of <code>&amp; T</code>, <code>&amp;mut T</code> or <code>With&lt;T&gt;</code> where <code>T</code> is some component or, as a special case, <code>Entity</code>. The result of <code>hobo::find</code> (or <code>hobo::find_one</code>) are tuples where each member is what was requested by the query (<code>With&lt;T&gt;</code> will always return <code>true</code> in its position because any entity that doesn't have <code>T</code> won't be included in the output).</p>
<p>Queries are also often useful to establish relations with distant <strong>Elements</strong>. For example, an <strong>Element</strong> in one part of the DOM can get an <strong>Element</strong> from a completely unrelated part of the DOM.</p>
<pre><code class="language-rust noplaypen">use hobo::create as e;

struct SettingsData {
    speed: f32,
}

let settings_container = e::div()
    // etc
    .component(SettingsData { speed: 0.35 })

// -- snip --

let unrelated_display = e::div()
    //etc
    .text(hobo::find_one::&lt;&amp;SettingsData&gt;().speed.to_string())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signals"><a class="header" href="#signals">Signals</a></h1>
<p>Hobo has some useful reactivity facilities. The core of this is <code>futures_signals::signal::Mutable</code>, from which signals are created, check the <a href="https://docs.rs/futures-signals/0.3">futures-signals</a> documentation for details on how to do that.</p>
<p>Hobo re-exports <code>futures_signals</code> as <code>hobo::signals</code>.</p>
<ul>
<li><code>text_signal</code>/<code>set_text_signal</code> - calls <code>set_text</code> whenever the signal value changes</li>
<li><code>child_signal</code>/<code>add_child_signal</code> - initially creates an empty <code>div</code>, then calls <code>.replace_with</code> every time the signal value changes</li>
<li><code>class_signal</code>/<code>set_class_signal</code> and <code>class_typed_signal</code>/<code>set_class_typed_signal</code> and <code>class_tagged_signal</code>/<code>set_class_tagged_signal</code> - calls <code>set_class_tagged</code> whenever the signal value changes
<ul>
<li>will always replace the first class so take care</li>
</ul>
</li>
<li><code>attr_signal</code>/<code>set_attr_signal</code> and <code>bool_attr_signal</code>/<code>set_bool_attr_signal</code> - calls <code>set_attr</code> whenever the signal value changes</li>
<li><code>style_signal</code>/<code>set_style_signal</code> - calls <code>set_style</code> whenever the signal value changes</li>
<li><code>mark_signal</code> - calls <code>mark</code>/<code>unmark</code> whenever the signal value changes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-the-dom"><a class="header" href="#building-the-dom">Building the DOM</a></h1>
<p>Assembling elements is usually done via function chaining, but every function has a non-chained variant for use in loops or in case ownership gets tricky.</p>
<p>Here's an example of a somewhat involved element:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use hobo::{prelude::*, create as e};

#[derive(hobo::Element)]
pub struct Input {
    element: e::Div,
    pub input: e::Input,
}

impl Input {
    pub fn new(caption_text: &amp;str, svg: Option&lt;e::Svg&gt;) -&gt; Self {
        let input = e::input()
            // shortcut for .attr(web_str::r#type(), web_str::text())
            .type_text()
            .class(css::class! {
                // some style
            });

        let caption_text = e::div()
            .text(caption_text)
            .class(css::class! {
                // some style
            });

        let mut element = e::div()
            .class(css::style! {
                // some style
            })
            .child(input)
            .child(caption_text);

        if let Some(svg) = svg {
            element.add_child(
                svg.class(css::class! {
                    // some style
                })
            );
        }

        Self { element, input }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="children"><a class="header" href="#children"><code>.children()</code></a></h3>
<p>Same as <code>.child()</code> but can consume an <code>impl IntoIterator</code>, convenient when taking a <code>Vec&lt;T&gt;</code> as an argument in list-like element constructors.<br />
There is no <code>.children_signal()</code> but it could potentially exist - PRs welcome!</p>
<h3 id="chaining-vs-non-chaining-syntax"><a class="header" href="#chaining-vs-non-chaining-syntax">Chaining vs non-chaining syntax</a></h3>
<p>Most functions have a chaining syntax, handy when constructing the element, and also non-chaining syntax for use in loops or other contexts. The convention is <code>.&lt;foo&gt;</code> for chaining and <code>.add_&lt;foo&gt;</code> for non-chaining. This goes against the more common Rust convention of <code>.with_&lt;foo&gt;</code> being the chaining syntax, this is because most code will be simple elements constructed in bulk, so most of these calls will be chaining so a shorter name is preferred.</p>
<ul>
<li><code>.child()</code>/<code>.child_signal()</code> vs <code>.add_child()</code>/<code>.add_child_signal()</code></li>
<li><code>.children()</code> vs <code>.add_children()</code></li>
<li><code>.class()</code>/<code>.class_tagged()</code>/<code>.class_typed()</code>/<code>.class_signal()</code> vs <code>.set_class()</code>/<code>.set_class_tagged()</code>/<code>.set_class_typed()</code>/<code>.set_class_signal()</code></li>
<li><code>.style()</code>/<code>.style_signal()</code> vs <code>.set_style()</code>/<code>.set_style_signal()</code></li>
<li><code>.attr()</code>/<code>.bool_attr()</code>/<code>.attr_signal()</code>/<code>.bool_attr_signal()</code> vs <code>.set_attr()</code>/<code>.set_bool_attr()</code>/<code>.set_attr_signal()</code>/<code>.set_bool_attr_signal()</code></li>
<li><code>.&lt;event&gt;()</code> vs <code>.add_&lt;event&gt;()</code></li>
<li><code>.text()</code>/<code>.text_signal()</code> vs <code>.set_text()</code>/<code>.set_text_signal()</code></li>
<li><code>.component()</code> vs <code>.add_component()</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-utilities"><a class="header" href="#other-utilities">Other utilities</a></h1>
<p>This chapter outlines useful helpers for common tasks that didn't make it into the core.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web_str"><a class="header" href="#web_str">web_str</a></h1>
<p>The <code>web_str</code> module is just a bunch of commonly used interned strings. It includes all element names, all event names and a bunch of common attributes and values like <code>class</code>, <code>min</code>, <code>max</code>, <code>checked</code>, <code>href</code>, <code>readonly</code>, etc. If something is missing - PRs welcome!</p>
<p>To read more about what is string interning and why is it useful: <a href="https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/fn.intern.html">wasm-bindgen docs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>There is a simple way to fire and respond to global events.</p>
<pre><code class="language-rust noplaypen">pub use hobo::{
    prelude::*,
    create as e,
};

struct MyEvent(u64);

fn make_foo() -&gt; impl hobo::AsElement {
    e::div()
        // etc children and styles
        .component(hobo::events::on(move |&amp;MyEvent(x)| {
            // do something with x
        }))
}

// -- snip --

hobo::events::fire(&amp;MyEvent(123));
</code></pre>
<p>The subscribers are notified based on event type, so it's better to create new types for different events rather than fire an event with a string or an enum.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipes"><a class="header" href="#recipes">Recipes</a></h1>
<p>This chapter outlines common idioms and patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>There is no stdout in the browser so the simplest way is to use the <a href="https://crates.io/crates/log">log</a> crate with <a href="https://crates.io/crates/wasm-logger">wasm-logger</a> and <a href="https://crates.io/crates/console_error_panic_hook">console_error_panic_hook</a> to see nicely formatted errors:</p>
<pre><code class="language-rust noplaypen">#[wasm_bindgen(start)]
pub fn main() {
    wasm_logger::init(wasm_logger::Config::default());
    console_error_panic_hook::set_once();

    // etc init and mounting of elements
    
    log::info!(&quot;it works!&quot;);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elements-that-change"><a class="header" href="#elements-that-change">Elements that change</a></h1>
<p>Since there's no VDOM, rebuilding the DOM is done manually by literally rebuilding the altered parts. It is on the developer to minimize this to maintain element focus, scroll position, performance, etc. The same goes for styling - any complex modification is best expressed as recreating the whole style.</p>
<p>However, most modifications can often be expressed with signals, with some child, style or text of an element just being a result of some computation based on one or multiple Mutables. With regards to styling in particular, most of the style is probably not going to change, with only minor changes based on something like theme.</p>
<pre><code class="language-rust noplaypen">.class_typed_signal::&lt;Theme, _, _&gt;(theme.signal().map(|theme| {
    match theme {
        Theme::Light =&gt; css::background_color!(css::color::WHITE),
        Theme::Dark =&gt; css::background_color!(css::color::BLACK),
    }
}))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="svgs"><a class="header" href="#svgs">SVGs</a></h1>
<p>There is a way to conveniently create inline SVGs without rewriting them manually with <code>hobo</code>'s syntax.</p>
<pre><code class="language-rust noplaypen">thread_local! {
    static LAST_ID: RefCell&lt;u64&gt; = RefCell::new(0);
}

fn get_svg_element(xml_node: &amp;roxmltree::Node, id: u64) -&gt; web_sys::SvgElement {
    let node: web_sys::SvgElement = wasm_bindgen::JsCast::unchecked_into(document().create_element_ns(Some(wasm_bindgen::intern(&quot;http://www.w3.org/2000/svg&quot;)), xml_node.tag_name().name()).unwrap());

    for attribute in xml_node.attributes() {
        // need to fixup ids to avoid id collisions in html if the same icon is used multiple times
        if attribute.name() == &quot;id&quot; {
            node.set_attribute(wasm_bindgen::intern(attribute.name()), &amp;format!(&quot;{}{:x}&quot;, attribute.value(), id)).unwrap();
        } else {
            let mut value = attribute.value().to_owned();
            // optimistic expectation that ids only used in url references
            if value.contains(&quot;url(#&quot;) {
                value = value.replace(')', &amp;format!(&quot;{:x})&quot;, id))
            }
            node.set_attribute(wasm_bindgen::intern(attribute.name()), &amp;value).unwrap();
        }
    }

    for child in xml_node.children().filter(roxmltree::Node::is_element) {
        node.append_child(&amp;get_svg_element(&amp;child, id)).unwrap();
    }

    node
}

macro_rules! svg {
    ($($name:ident =&gt; $address:expr),*$(,)*) =&gt; {$(
        #[must_use]
        pub fn $name() -&gt; e::Svg {
            let id = LAST_ID.with(move |last_id| {
                let mut last_id = last_id.borrow_mut();
                let id = *last_id;
                *last_id += 1;
                id
            });
            let element: web_sys::SvgElement = get_svg_element(&amp;roxmltree::Document::parse(include_str!($address)).unwrap().root_element(), id);
            e::Svg(hobo::create::svg_element(&amp;element))
        }
    )*};
}

svg![
    logo =&gt; r&quot;../../public/img/icons/etc/logo.svg&quot;,
    discord =&gt; r&quot;../../public/img/icons/shapes/discord.svg&quot;,
];
</code></pre>
<h2 id="constructing-inline-svgs"><a class="header" href="#constructing-inline-svgs">Constructing inline SVGs</a></h2>
<p>Of course, if you need to algorithmically construct an svg, such as if you're making a chart, you can do that too:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let svg = e::svg()
    .attr(web_str::viewBox(), &quot;-1 -1 2 2&quot;)
    .child(e::circle()
        .attr(web_str::cx(), &quot;0&quot;)
        .attr(web_str::cy(), &quot;0&quot;)
        .attr(web_str::r(), &quot;1&quot;)
        .class((
            css::fill!(colors::gray6),
        ))
    );
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-and-is_dead"><a class="header" href="#async-and-is_dead">Async and .is_dead()</a></h1>
<p>Be careful accessing entities with abandon from an async context. Make sure to check that your entity is still mounted by the time your async computations finish and you're trying to change something.</p>
<pre><code class="language-rust noplaypen">use std::future::Future;

pub fn spawn_complain&lt;T&gt;(x: impl Future&lt;Output = anyhow::Result&lt;T&gt;&gt; + 'static) {
    wasm_bindgen_futures::spawn_local(async move { if let Err(e) = x.await {
        log::error!(&quot;{:?}&quot;, e);
    }});
}

e::div()
    .with(move |&amp;element| spawn_complain(async move {
        let value = do_some_request_or_something().await?;
        if element.is_dead() { return Ok(()); }
        element.set_text(value);
        Ok(())
    }))
</code></pre>
<p>This isn't necessary outside of async context because wasm is single-threaded so your element can't get unmounted due to user actions, but in some complex scenarios it might be useful anyway.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
